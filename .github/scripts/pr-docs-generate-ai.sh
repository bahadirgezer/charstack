#!/usr/bin/env bash
set -euo pipefail

: "${PR_DOCS_DIR:?PR_DOCS_DIR is required}"
: "${GEMINI_API_KEY:?GEMINI_API_KEY is required}"

MODEL="${GEMINI_MODEL:-gemini-2.0-flash}"
CONTEXT_JSON="$PR_DOCS_DIR/context.json"

if [[ ! -f "$CONTEXT_JSON" ]]; then
  echo "::error::Missing context file: $CONTEXT_JSON"
  exit 1
fi

PROMPT="$(cat <<'PROMPT_EOF'
You produce PR documentation for senior engineers.

Write markdown only. Be terse, concrete, and useful at a glance.
No hype, no filler, no AI disclaimers, no code fences.

Required structure:
## At a Glance
- 3-5 bullets: highest-impact changes and intent.

## This Push
- If this event is synchronize and push context is available: describe only what changed in this push.
- Otherwise: write exactly `- No incremental push delta for this event.`

## Review Focus
- 2-4 bullets: risk areas, regressions to watch, what reviewers should verify.

## Details
- Group concrete changes by area with short bullets.

Rules:
- 140-260 words.
- Mention behavior/user impact when inferable.
- If action is closed, explicitly state whether PR was merged.
- If tests are not visible in the diff/commits, say verification is not shown.
PROMPT_EOF
)"

CONTEXT_PAYLOAD="$(jq -n \
  --arg prompt "$PROMPT" \
  --argjson meta "$(cat "$CONTEXT_JSON")" \
  --arg full_shortstat "$(cat "$PR_DOCS_DIR/full_shortstat.txt")" \
  --arg full_diff_stat "$(cat "$PR_DOCS_DIR/full_diff_stat.txt")" \
  --arg full_commits "$(cat "$PR_DOCS_DIR/full_commits.txt")" \
  --arg full_patch "$(cat "$PR_DOCS_DIR/full_diff_patch.txt")" \
  --arg push_shortstat "$(cat "$PR_DOCS_DIR/push_shortstat.txt")" \
  --arg push_diff_stat "$(cat "$PR_DOCS_DIR/push_diff_stat.txt")" \
  --arg push_commits "$(cat "$PR_DOCS_DIR/push_commits.txt")" \
  --arg push_patch "$(cat "$PR_DOCS_DIR/push_diff_patch.txt")" \
  '{
    contents: [{
      parts: [{
        text: (
          $prompt
          + "\n\n--- META ---\n" + ($meta | tostring)
          + "\n\n--- FULL PR SHORTSTAT ---\n" + $full_shortstat
          + "\n\n--- FULL PR DIFF STAT ---\n" + $full_diff_stat
          + "\n\n--- FULL PR COMMITS ---\n" + $full_commits
          + "\n\n--- FULL PR DIFF PATCH (TRUNCATED) ---\n" + $full_patch
          + "\n\n--- PUSH SHORTSTAT ---\n" + $push_shortstat
          + "\n\n--- PUSH DIFF STAT ---\n" + $push_diff_stat
          + "\n\n--- PUSH COMMITS ---\n" + $push_commits
          + "\n\n--- PUSH DIFF PATCH (TRUNCATED) ---\n" + $push_patch
        )
      }]
    }],
    generationConfig: {
      temperature: 0.15,
      topP: 0.9,
      maxOutputTokens: 700
    }
  }'
)"

RESPONSE_FILE="$PR_DOCS_DIR/gemini_response.json"
HTTP_CODE="$(curl -sS -o "$RESPONSE_FILE" -w '%{http_code}' \
  "https://generativelanguage.googleapis.com/v1beta/models/${MODEL}:generateContent?key=${GEMINI_API_KEY}" \
  -H "Content-Type: application/json" \
  -d "$CONTEXT_PAYLOAD")"

BODY="$(jq -r '.candidates[0].content.parts[0].text // empty' "$RESPONSE_FILE")"
ERROR_STATUS="$(jq -r '.error.status // empty' "$RESPONSE_FILE")"
ERROR_MESSAGE="$(jq -r '.error.message // empty' "$RESPONSE_FILE")"

if [[ -n "${BODY//[[:space:]]/}" ]]; then
  {
    printf '%s\n\n' "$BODY"
    printf -- '---\n_Autogenerated by Gemini %s._\n' "$MODEL"
  } > "$PR_DOCS_DIR/generated_block.md"
  echo "Gemini PR docs generated."
  exit 0
fi

is_usage_limit_error="false"
if [[ "$HTTP_CODE" == "429" || "$ERROR_STATUS" == "RESOURCE_EXHAUSTED" ]]; then
  is_usage_limit_error="true"
fi
if echo "$ERROR_MESSAGE" | grep -Eiq 'usage|quota|rate.?limit|resource.?exhausted|too many requests'; then
  is_usage_limit_error="true"
fi

if [[ "$is_usage_limit_error" == "true" ]]; then
  echo "Gemini usage limit hit (${HTTP_CODE}/${ERROR_STATUS})." >&2
  exit 42
fi

echo "::error::Gemini generation failed (HTTP ${HTTP_CODE}, status ${ERROR_STATUS})."
if [[ -n "$ERROR_MESSAGE" ]]; then
  echo "::error::${ERROR_MESSAGE}"
fi
exit 1
