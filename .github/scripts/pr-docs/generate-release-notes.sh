#!/usr/bin/env bash
set -euo pipefail

: "${CHANGELOG_FILE:?CHANGELOG_FILE is required}"
: "${OUTPUT_FILE:?OUTPUT_FILE is required}"
: "${GROQ_API_KEY:?GROQ_API_KEY is required}"

MODEL="${GROQ_MODEL:-groq/compound}"
API_URL="${GROQ_API_URL:-https://api.groq.com/openai/v1/chat/completions}"
MAX_PAYLOAD_BYTES="${MAX_GROQ_PAYLOAD_BYTES:-45000}"

if [[ ! -f "$CHANGELOG_FILE" ]]; then
  echo "::error::Missing changelog file: $CHANGELOG_FILE"
  exit 1
fi

CHANGELOG="$(cat "$CHANGELOG_FILE")"

SYSTEM_PROMPT="You write release notes for senior engineers and users. Return concise markdown. Be brief. No code fences."
USER_CONTEXT="$(cat <<EOF
Write concise, user-friendly release notes for an iOS app based on this changelog.
Group changes by category (Features, Fixes, Maintenance). Use markdown bullets.
Be brief and specific; avoid generic filler.

Changelog:
$CHANGELOG
EOF
)"

USER_CONTEXT="${USER_CONTEXT:0:22000}"

build_payload() {
  local trimmed_context="$1"
  jq -n \
    --arg model "$MODEL" \
    --arg system "$SYSTEM_PROMPT" \
    --arg user "$trimmed_context" \
    --argjson max_tokens 520 \
    '{
      model: $model,
      messages: [
        {role: "system", content: $system},
        {role: "user", content: $user}
      ],
      temperature: 0.1,
      max_tokens: $max_tokens
    }'
}

trim_limit="${#USER_CONTEXT}"
PAYLOAD=""
PAYLOAD_BYTES=0

while true; do
  trimmed_context="${USER_CONTEXT:0:$trim_limit}"
  PAYLOAD="$(build_payload "$trimmed_context")"
  PAYLOAD_BYTES="$(printf '%s' "$PAYLOAD" | wc -c | tr -d ' ')"

  if (( PAYLOAD_BYTES <= MAX_PAYLOAD_BYTES )) || (( trim_limit <= 1200 )); then
    break
  fi

  trim_limit=$((trim_limit * 3 / 4))
done

RESPONSE_FILE="$(mktemp)"
HTTP_CODE="$(curl -sS -o "$RESPONSE_FILE" -w '%{http_code}' \
  "$API_URL" \
  -H "Authorization: Bearer ${GROQ_API_KEY}" \
  -H "Content-Type: application/json" \
  -d "$PAYLOAD")"

BODY="$(jq -r '.choices[0].message.content // empty' "$RESPONSE_FILE")"
ERROR_MESSAGE="$(jq -r '.error.message // empty' "$RESPONSE_FILE")"
ERROR_TYPE="$(jq -r '.error.type // empty' "$RESPONSE_FILE")"

rm -f "$RESPONSE_FILE"

if [[ -n "${BODY//[[:space:]]/}" ]]; then
  {
    printf '%s\n\n' "$BODY"
    printf -- '---\n_Autogenerated by Groq %s._\n' "$MODEL"
  } > "$OUTPUT_FILE"
  echo "Groq release notes generated."
  exit 0
fi

recoverable_error="false"
if [[ "$HTTP_CODE" == "429" ]]; then
  recoverable_error="true"
fi
if echo "$ERROR_MESSAGE" | grep -Eiq 'rate.?limit|quota|too many requests|usage limit|resource exhausted|context length|prompt too long|request too large|token|model.+(not found|does not exist|unavailable)'; then
  recoverable_error="true"
fi

if [[ "$recoverable_error" == "true" ]]; then
  echo "Groq recoverable failure (${HTTP_CODE}/${ERROR_TYPE}): ${ERROR_MESSAGE}" >&2
  exit 42
fi

echo "::error::Groq generation failed (HTTP ${HTTP_CODE}, type ${ERROR_TYPE})."
if [[ -n "$ERROR_MESSAGE" ]]; then
  echo "::error::${ERROR_MESSAGE}"
fi
exit 1
