name: Release

on:
  push:
    branches: [master, develop]
  workflow_dispatch:
    inputs:
      bump:
        description: "Version bump (default: auto by branch)"
        type: choice
        options:
          - auto
          - patch
          - minor
          - major
          - none
        default: auto
      version_override:
        description: "Override release version (x.y.z)"
        required: false

permissions:
  contents: write

concurrency:
  group: release-${{ github.ref_name }}
  cancel-in-progress: false

jobs:
  release:
    name: Tag & Release
    runs-on: [self-hosted, macOS, ARM64, bgpro-charstack]
    timeout-minutes: 60
    environment: ${{ github.ref_name == 'master' && 'production' || 'development' }}

    steps:
      - name: Checkout
        uses: actions/checkout@v6
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Select Xcode
        if: vars.XCODE_APP_PATH != ''
        run: |
          sudo xcode-select -s "${{ vars.XCODE_APP_PATH }}"
          xcodebuild -version

      # ── Compute release version ──
      - name: Compute version
        id: ver
        run: |
          REF_NAME="${{ github.ref_name }}"
          INPUT_BUMP="${{ github.event.inputs.bump || 'auto' }}"
          INPUT_OVERRIDE="${{ github.event.inputs.version_override || '' }}"

          # If an explicit override is given, use it directly
          if [[ -n "$INPUT_OVERRIDE" ]]; then
            if ! [[ "$INPUT_OVERRIDE" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
              echo "::error::version_override must be x.y.z — got '$INPUT_OVERRIDE'"
              exit 1
            fi
            FINAL_VERSION="$INPUT_OVERRIDE"
          else
            # Determine bump type
            BUMP="$INPUT_BUMP"
            if [[ "$BUMP" == "auto" ]]; then
              case "$REF_NAME" in
                develop) BUMP="patch" ;;
                master)  BUMP="minor" ;;
                *)
                  echo "::error::Auto bump only supported on develop/master."
                  exit 1
                  ;;
              esac
            fi

            if [[ "$BUMP" == "none" ]]; then
              echo "skip=true" >> "$GITHUB_OUTPUT"
              exit 0
            fi

            # Find the latest tag for THIS branch type
            if [[ "$REF_NAME" == "develop" ]]; then
              # develop tags: v1.2.3-dev
              LATEST_TAG="$(git tag --list 'v[0-9]*.[0-9]*.[0-9]*-dev' --sort=-v:refname | head -1 || true)"
            else
              # master tags: v1.2.0 (no suffix)
              LATEST_TAG="$(git tag --list 'v[0-9]*.[0-9]*.[0-9]*' --sort=-v:refname | grep -v '\-' | head -1 || true)"
            fi

            # Strip prefix and suffix to get bare version
            LATEST_VERSION="${LATEST_TAG#v}"
            LATEST_VERSION="${LATEST_VERSION%-dev}"

            # Also read VERSION file as fallback
            BASE="$(tr -d '[:space:]' < VERSION)"
            if ! [[ "$BASE" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
              echo "::error::VERSION must be x.y.z — got '$BASE'"
              exit 1
            fi

            # Use whichever is higher: latest tag or VERSION file
            export BASE
            export LATEST="$LATEST_VERSION"
            export BUMP

            FINAL_VERSION="$(python3 - <<'PY'
          import os, re

          base = os.environ["BASE"]
          latest = os.environ.get("LATEST", "")
          bump = os.environ["BUMP"]

          def parse(v):
              m = re.match(r"^(\d+)\.(\d+)\.(\d+)$", v)
              if not m:
                  return None
              return tuple(int(x) for x in m.groups())

          base_t = parse(base)
          latest_t = parse(latest) if latest else None

          ref = base_t
          if latest_t and latest_t > ref:
              ref = latest_t

          if bump == "patch":
              out = (ref[0], ref[1], ref[2] + 1)
          elif bump == "minor":
              out = (ref[0], ref[1] + 1, 0)
          elif bump == "major":
              out = (ref[0] + 1, 0, 0)
          else:
              raise SystemExit(f"Unsupported bump: {bump}")

          print("{}.{}.{}".format(*out))
          PY
            )"
          fi

          # Build the tag name (develop gets -dev suffix)
          if [[ "$REF_NAME" == "develop" ]]; then
            TAG="v${FINAL_VERSION}-dev"
          else
            TAG="v${FINAL_VERSION}"
          fi

          # Check tag doesn't already exist
          if git ls-remote --tags origin "refs/tags/$TAG" | grep -q .; then
            echo "::error::Tag $TAG already exists on remote."
            exit 1
          fi

          echo "version=$FINAL_VERSION" >> "$GITHUB_OUTPUT"
          echo "tag=$TAG" >> "$GITHUB_OUTPUT"
          echo "skip=false" >> "$GITHUB_OUTPUT"

          # Determine if this is a prerelease (develop) or full release (master)
          if [[ "$REF_NAME" == "develop" ]]; then
            echo "prerelease=true" >> "$GITHUB_OUTPUT"
          else
            echo "prerelease=false" >> "$GITHUB_OUTPUT"
          fi

      # ── Early exit if bump=none ──
      - name: Skip release
        if: steps.ver.outputs.skip == 'true'
        run: echo "Bump is 'none' — skipping release."

      # ── Create & push tag ──
      - name: Create tag
        if: steps.ver.outputs.skip != 'true'
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git tag -a "${{ steps.ver.outputs.tag }}" -m "Release ${{ steps.ver.outputs.tag }}"
          git push origin "${{ steps.ver.outputs.tag }}"

      # ── Update VERSION file ──
      - name: Update VERSION file
        if: steps.ver.outputs.skip != 'true'
        run: |
          echo "${{ steps.ver.outputs.version }}" > VERSION
          if git diff --quiet VERSION; then
            echo "VERSION file already up to date."
          else
            git add VERSION
            git commit -m "chore: bump VERSION to ${{ steps.ver.outputs.version }} [skip ci]"
            git push origin HEAD:${{ github.ref_name }}
          fi

      # ── Build release archive ──
      - name: Resolve Xcode project
        if: steps.ver.outputs.skip != 'true'
        id: xcode
        run: .github/scripts/resolve-xcode-project.sh
        env:
          INPUT_WORKSPACE: ${{ vars.XCODE_WORKSPACE }}
          INPUT_PROJECT: ${{ vars.XCODE_PROJECT }}
          INPUT_SCHEME: ${{ vars.XCODE_SCHEME }}

      - name: Build archive
        if: steps.ver.outputs.skip != 'true'
        run: |
          mkdir -p build
          xcodebuild \
            "${{ steps.xcode.outputs.flag }}" "${{ steps.xcode.outputs.path }}" \
            -scheme "${{ steps.xcode.outputs.scheme }}" \
            -configuration Release \
            -destination "platform=iOS Simulator,name=iPhone 17 Pro" \
            -archivePath build/App.xcarchive \
            MARKETING_VERSION="${{ steps.ver.outputs.version }}" \
            CURRENT_PROJECT_VERSION="${{ github.run_number }}" \
            CODE_SIGN_IDENTITY="-" \
            CODE_SIGNING_REQUIRED=NO \
            CODE_SIGNING_ALLOWED=NO \
            clean archive

      - name: Zip archive
        if: steps.ver.outputs.skip != 'true'
        run: |
          /usr/bin/ditto -c -k --sequesterRsrc --keepParent \
            build/App.xcarchive build/App.xcarchive.zip

      # ── Generate changelog from git log ──
      - name: Generate changelog
        if: steps.ver.outputs.skip != 'true'
        run: |
          TAG="${{ steps.ver.outputs.tag }}"
          REF_NAME="${{ github.ref_name }}"

          # Find previous tag for the same branch type
          if [[ "$REF_NAME" == "develop" ]]; then
            PREV_TAG="$(git tag --list 'v[0-9]*.[0-9]*.[0-9]*-dev' --sort=-v:refname \
              | grep -vx "$TAG" | head -1 || true)"
          else
            PREV_TAG="$(git tag --list 'v[0-9]*.[0-9]*.[0-9]*' --sort=-v:refname \
              | grep -v '\-' | grep -vx "$TAG" | head -1 || true)"
          fi

          {
            echo "# Changelog — $TAG"
            echo
            if [[ -n "$PREV_TAG" ]]; then
              echo "_Changes since ${PREV_TAG}_"
              echo
              git log --no-merges --pretty=format:"- %s" "${PREV_TAG}..HEAD"
            else
              echo "_Initial release_"
              echo
              git log --no-merges --pretty=format:"- %s"
            fi
            echo
          } > build/CHANGELOG.md

      # ── AI-enhanced release notes (optional) ──
      - name: Generate AI release notes
        if: steps.ver.outputs.skip != 'true'
        id: ai_notes
        env:
          GROQ_API_KEY: ${{ secrets.GROQ_API_KEY }}
          GROQ_MODEL: groq/compound
        run: |
          if [[ -z "${GROQ_API_KEY:-}" ]]; then
            echo "has_notes=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          CHANGELOG_FILE="build/CHANGELOG.md"
          OUTPUT_FILE="build/RELEASE_NOTES.md"

          set +e
          CHANGELOG_FILE="$CHANGELOG_FILE" OUTPUT_FILE="$OUTPUT_FILE" \
            .github/scripts/pr-docs/generate-release-notes.sh
          status=$?
          set -e

          if [[ $status -eq 0 ]]; then
            echo "has_notes=true" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          if [[ $status -eq 42 ]]; then
            echo "has_notes=false" >> "$GITHUB_OUTPUT"
            echo "Groq unavailable/rate-limited; using changelog."
            exit 0
          fi

          exit $status

      # ── Create GitHub Release ──
      - name: Create GitHub Release
        if: steps.ver.outputs.skip != 'true'
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.ver.outputs.tag }}
          name: ${{ steps.ver.outputs.tag }}
          body_path: ${{ steps.ai_notes.outputs.has_notes == 'true' && 'build/RELEASE_NOTES.md' || 'build/CHANGELOG.md' }}
          prerelease: ${{ steps.ver.outputs.prerelease == 'true' }}
          generate_release_notes: false
          files: |
            build/App.xcarchive.zip
            build/CHANGELOG.md
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
